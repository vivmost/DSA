# Arrays and Matrices
    1. Rotate an Array.
    2. Exit point of matrix.
    3. Rotate by 90.
    4. Saddle Price.
    5. Ring Rotate.

# Strings
    1. String With Difference Of Every Two Consecutive Characters.

# Recursion and Backtracking
    1. Tower Of Hanoi.
    2. All indices of an array.
    3. Get kpc.
    4. Get stairs path.
    5  Print Subsequences.
    6. Flood Fill.
    7. N_Queens.
    8. Knights Tour.

# DP and Greedy
    1. Climb Stairs.
    2. Min Cost In Maze Traversal.
    3. Goldmine.
    4. Target Sum Subsets.
    5. Coin Change Combinations.
    6. 0-1 Knapsack.
    7. Unbounded Knapsack.
    8. Fractional Knapsack.
    9. Count Binary Strings.
    10. Count Encodings.
    11. Count A+B+C+ subsequences.
    12. Maximum Sum Non Adjacent Elements.
    13. Paint Houses Many Colors.
    14. Tiling With (M x 1) Tiles.
    15. Buy And Sell Stocks With Transaction Fee Infinite Transactions Allowed.
    16. Buy And Sell Stocks With Cooldown Infinite Transactions Allowed.
    17. Buy And Sell Stocks Two Transactions Allowed.
    18. Buy And Sell Stocks K Transactions Allowed.
        
# Sorting 
    1. Merge Sort.
    2. Quick Sort.
    3. Quick Select.
    4. Count Sort.
    5. Radix Sort.
    6. Sort 012.
    7. Sort Dates.
    8. Target sum pair 1 --> (2 pointers).
    9. Pivot In Sorted And Rotated Array.

# Stacks and Queues
    1. Duplicate Brackets.
    2. Next Greater Element.
    3. Stock Span.
    4. Largest Area Histogram.
    5. Sliding Window Maximum.
    6. Infix Evaluation.
    7. Infix Conversions. 
    8. Prefix Evaluations Conversions.
    9. Postfix Evaluations Conversions.
    10. Celebrity Problem.
    11. Merge Overlapping Intervals.
    12. Stack Implementations(Static and Dynamic).
    13. Minimum Stack Constant Space.
    14. Queue Implementations(Static and Dynamic).
    15. Two Stacks In An Array.
    
# Linked Lists
    1. Linked List Implementation.
    2. Reverse A Linked list(Data and Pointer Iterative).
    3. Kth Node From The End --> (Slow and Fast Pointers).
    4. Mid OF Linked List --> (Slow and Fast Pointers).
    5. K Reverse In A Linked List.
    6. Display A Linked List Recursive.
    7. Reverse A Linked List Pointer Recursive.
    8. Is Linked List A Paliandrome.
    9. Fold A Linked List.
    10. Add 2 Linked Lists.
    
# Trees
    ## Generic Tree
        1. Size Of A Generic Tree.
        2. Maximum In A Genric Tree.
        3. Height Of A Tree.
        4. Level Order Of Generic Tree.
        5. Level Order Line Wise.
        6. Level Order Line Wise Zig-Zag.
        7. Remove Leaves In Generic Tree. 
        8. Linearize A Generic Tree.
        9. Lowest Common Ancestor of Generic Tree.
        10. Distance Between Two Nodes In A Generic Tree.
        11. Are Trees Mirror In Shape.  
        12. Predecessor and Succesor Of An Element (Multisolver for Generic Tree method used).
        13. Ceil and Floor In Generic Tree.
        14. Kth Largest Element.
        15. Node With Maximum Subtree Sum.
        16. Iterative Preorder Postorder Generic Tree.

    ## Binary Tree
        1. Size Sum Max_Height.
        2. Node To Root Path.
        3. Print k Levels Down.
        4. Print Nodes K Distance Awaay.
        5. Path To Leaf From Root In Range.
        6. Transform To Left Cloned Tree.
        7. Tranform To Normal From Left Cloned Tree.
        8. Print Single Child Nodes.
        9. Remove Leaves Binary Tree.
        10. Diameter Of Binary Tree.
        11. Tilt Of Binary Tree.
        12. Is A BST.
        13. Is Binary Tree balanced.

    ## BST
        1. Size Sum Max Min Find In BST.
        2. Remove Node In BST.
        3. Replace With Sum Of Larger.
        4. LCA of BST.
        5. Print Range.
        6. Target Sum Pairs (Both Problem and Optimal Explanation).
    
# Hashmap and Heaps
    1. Get Common Elements 1.
    2. Get Common Elements 2.
    3. Longest Consecutive Sequence Of Elements.
    4. Sort K Sorted Array.
    5. Median Priority Queue.
    6. Merge K Sorted Lists.
    7. Write Priority Queue Using Heap (Efficient Heap Constructor). 
    8. Write Hashmap.

# Graphs
    1. Has Path.
    2. Print All Paths.